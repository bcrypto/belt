\chapter{Общие положения}\label{COMMON}

\section{Назначение}

Настоящий стандарт определяет семейство криптографических алгоритмов,
предназначенных для обеспечения конфиденциальности и контроля 
целостности данных. Обрабатываемыми данными являются двоичные слова 
(сообщения). 

Криптографические алгоритмы стандарта построены на основе 
базовых алгоритмов шифрования блока, 
шифрования широкого блока и криптографического сжатия.
Базовые алгоритмы определяются в~\ref{BASE}.

Криптографические алгоритмы шифрования и контроля целостности
делятся на десять групп:
\begin{enumerate}
\item[1)]
алгоритмы шифрования в режиме простой замены (\ref{ECB});
\item[2)]
алгоритмы шифрования в режиме сцепления блоков (\ref{CBC});
\item[3)]
алгоритмы шифрования в режиме гаммирования с обратной связью (\ref{CFB});
\item[4)]
алгоритмы шифрования в режиме счетчика (\ref{CTR});
\item[5)]
алгоритм выработки имитовставки (\ref{MAC});
\item[6)]
алгоритмы аутентифицированного шифрования данных (\ref{AE});
\item[7)]
алгоритмы аутентифицированного шифрования ключа (\ref{KWP});
\item[8)]
алгоритм хэширования (\ref{HASH});
\item[9)]
алгоритмы дискового шифрования (\ref{DSK});
\item[10)]
алгоритмы шифрования с сохранением формата (\ref{FMT}).
\end{enumerate}

Первые четыре группы предназначены для обеспечения конфиденциальности сообщений. 
Каждая группа включает алгоритм зашифрования и алгоритм расшифрования.
Стороны, располагающие общим ключом, могут организовать 
конфиденциальный обмен сообщениями путем их зашифрования 
перед отправкой и расшифрования после получения.
%
В режимах простой замены и сцепления блоков шифруются сообщения,
которые содержат хотя бы один блок, 
а в режимах гаммирования с обратной связью и счетчика~--- 
сообщения произвольной длины.
%
В режиме простой замены следует зашифровывать только 
высокоэнтропийные данные: ключи, случайные или псевдослучайные числа.
%
%\doubt{без контроля противника?}

Пятый алгоритм предназначен для контроля целостности сообщений
с помощью имитовставок~--- контрольных слов, 
которые определяются с использованием ключа.
%
Стороны, располагающие общим ключом, 
могут организовать контроль целостности при обмене сообщениями
путем добавления к ним имитовставок при отправке 
и проверки имитовставок при получении.
%
Проверка имитовставок дополнительно позволяет стороне-получателю 
убедиться в том, что сторона-отправитель знает ключ,
т.~е. позволяет проверить подлинность сообщений.

Шестая и седьмая группы предназначены для обеспечения конфиденциальности 
и контроля целостности сообщений. 
%
Контроль целостности снова сопровождается контролем подлинности.
%
Каждая группа включает алгоритмы установки и снятия защиты. 

В алгоритмах шестой группы контролируется целостность сообщения в паре с 
ассоциированными открытыми данными. 
%
При установке защиты вычисляется имитовставка пары и одновременно 
выполняется зашифрование сообщения. 
%
При снятии защиты имитовставка проверяется и,
если проверка прошла успешно, сообщение расшифровывается.

В шестой группе реализованы две схемы аутентифицированного шифрования.
%
Алгоритмы первой схемы хорошо совместимы с алгоритмами шифрования в режиме счетчика, 
фактически образуя расширение данных алгоритмов.
%
Алгоритмы второй схемы более эффективны: при обработке одних и тех же данных  
требуется на одно шифрование блока меньше.

В алгоритмах седьмой группы длина защищаемого сообщения должна быть сразу известна,
эти алгоритмы следует применять для защиты ключей.
Защищаемый ключ сопровождается открытым заголовком, 
который содержит открытые атрибуты ключа и одновременно
является контрольным значением при проверке целостности. 
%
Могут использоваться фиксированные постоянные заголовки, 
которые служат только для контроля целостности.
%
При установке защиты ключ зашифровывается вместе со своим заголовком
и формируется слово, которое является одновременно 
защищенным ключом и имитовставкой ключа.
%
При снятии защиты выполняется обратное преобразование
и расшифрованный заголовок сравнивается с контрольным.

Восьмой алгоритм предназначен для вычисления
хэш-значений~--- контрольных слов, 
которые определяются без использования ключа.
%
Стороны могут организовать контроль целостности сообщений
путем сравнения их хэш-значений с достоверными контрольными хэш-значениями.
%
Изменение сообщения с высокой вероятностью
приводит к изменению соответствующего хэш-значения
и поэтому хэш-значения могут использоваться вместо самих сообщений,
например в системах электронной цифровой подписи.

Алгоритмы девятой группы предназначены для шифрования содержимого дисков и 
других накопителей данных. Диск разбивается на секторы, состоящие из полного 
числа блоков. Каждый сектор имеет уникальный номер, который учитывается при 
шифровании. Содержимое сектора может обновляться и зашифровываться многократно.
Объем сектора при шифровании не меняется.

Шифрование может быть организовано двумя способами. 
%
При блоковом шифровании блоки секторов обрабатываются независимо друг от друга,
способ обработки зависит от номера сектора и номера блока в секторе. 
%
При секторном шифровании все блоки сектора обрабатываются вместе,
способ обработки зависит от номера сектора.
%
При выборе способа шифрования следует учитывать, что блоковое шифрование 
выполняется примерно в 2 раза быстрее секторного, однако при повторном 
шифровании того же блока в той же позиции того же сектора будет получен тот же 
результат.

Алгоритмы десятой группы шифруют слова длины~$n\geq 2$
в алфавите из $m$~символов. Символы алфавита кодируются числами от~$0$ 
до~$m-1$ и, таким образом, алфавит представляет собой множество~$\ZZ_m$. 
Правила кодирования определяются за рамками настоящего стандарта. 
%
Алгоритмы сохраняют формат: 
результатом шифрования слова в алфавите~$\ZZ_m$ является слово в том
же алфавите той же длины.

Дополнительно в разделе~\ref{HELPERS} определяются
служебные алгоритмы расширения и преобразования ключа, 
предназначенные для создания и модификации ключей
шифрования и имитозащиты.

В приложении~\ref{TEST} приводятся примеры выполнения алгоритмов стандарта.
Примеры можно использовать для проверки корректности реализаций 
алгоритмов.

В приложении~\ref{ASN} приводится модуль
абстрактно-синтаксической нотации версии~1 (АСН.1),
определенной в~ГОСТ 34.973.
Модуль задает идентификаторы алгоритмов стандарта и описывает
форматы параметров алгоритмов. 
%
Рекомендуется использовать модуль 
при встраивании алгоритмов в информационные системы, 
в которых также используется АСН.1.

\section{Ключ}\label{COMMON.Key}

В алгоритмах шифрования и имитозащиты используется 
ключ~$K\in\{0,1\}^{256}$.
%
Ключ должен вырабатываться без возможности предсказания, 
распространяться с соблюдением мер конфиденциальности и храниться в секрете.

Разрешается использовать ключ~$K$,
полученный в результате расширения короткого ключа длины~$128$ или~$192$. 
При этом должен использоваться алгоритм расширения,
заданный в~\ref{KEYEXPAND}.

Один и тот же ключ не должен использоваться в алгоритмах различных групп. 
%
Ключ аутентифицированного шифрования данных по схеме 1 не должен использоваться 
как ключ схемы 2 и наоборот.
%
Ключ блокового дискового шифрования не должен использоваться как ключ 
секторного и наоборот.

Ключи шифрования данных должны применяться в соответствии с квотами,
определенными в приложении~\ref{QUOTAS}.
%
Ключ шифрования с сохранением формата не должен использоваться 
(даже с разными синхропосылками) более~$m^n$ раз.

В~\ref{KEYREP} определяется алгоритм преобразования ключа, 
с помощью которого по исходному ключу можно строить наборы новых ключей,
которые, в свою очередь, также можно преобразовывать.
%
Алгоритм преобразования может применяться для создания семейств ключей 
различного назначения, в том числе для использования в алгоритмах 
шифрования и имитозащиты различных групп.
%
Кроме этого, алгоритм преобразования позволяет организовать
обновление ключей при исчерпании лимитов времени их использования 
или объема обработанных на ключах данных.

Ключам, которые требуется получить в результате преобразования, 
ставятся в соответствие заголовки $I\in\{0,1\}^{128}$,
содержащие открытые атрибуты ключей, например, тип или назначение.
%
Кроме этого, ключам назначаются уровни~$D\in\{0,1\}^{96}$.
%
Исходному ключу назначается уровень~$\itob{0}_{96}$.
%
Алгоритм преобразования по ключу уровня~$D$ и заголовку~$I$
строит новый ключ уровня~$D\boxplus\itob{1}_{96}$
с заголовком~$I$.
%
Многократное применение алгоритма к одному ключу с различными 
заголовками~$I$ соответствует генерации семейства ключей 
различного назначения.
%
Последовательное применение алгоритма к одному ключу 
с сохранением заголовка~$I$ соответствует обновлению ключа.

\section{Синхропосылка}\label{COMMON.IV}

При шифровании в режимах сцепления блоков, гаммирования 
с обратной связью и счетчика, аутентифицированном шифровании данных, 
дисковом шифровании, шифровании с сохранением формата
используется синхропосылка~$S\in\{0,1\}^{128}$.

Синхропосылка не является секретным параметром, 
может добавляться к зашифрованному сообщению и передаваться вместе с ним.

При шифровании в режимах гаммирования с обратной связью и счетчика, 
а также при аутентифицированном шифровании данных должны использоваться 
уникальные синхропосылки.
%
Уникальность означает, что при зашифровании или установке защиты 
на одном и том же ключе используются либо заведомо различные синхропосылки,
либо вероятность совпадения синхропосылок пренебрежимо мала.

В режиме сцепления блоков синхропосылка должна быть не только 
уникальной, но и непредсказуемой.
%
Непредсказуемость означает, что синхропосылки формируются случайно
или по секретным правилам и вероятность угадать, 
какая синхропосылка будет использоваться, пренебрежимо мала.

Синхропосылки можно вырабатывать случайным или псевдослучайным 
методом, строить по отметкам времени, значениям монотонного счетчика, 
неповторяющимся номерам сообщений и др.
%
В режиме сцепления блоков предсказуемые значения не должны
использоваться напрямую для построения синхропосылок, 
а должны предварительно зашифроваться на том же ключе, 
который используется для шифрования сообщений.

При шифровании с сохранением формата синхропосылка 
по умолчанию нулевая: $S=0^{128}$.
%
Уникальные синхропосылки следует использовать в ситуациях,
когда размер алфавита~$m$ и длина шифруемых слов~$n$ невелики.
%
В этих ситуациях у противника имеется возможность накопления 
результатов зашифрования значительной части из~$m^n$ возможных открытых 
сообщений. 
%
Уникальные синхропосылки не позволяют использовать накопленные 
данные для расшифрования будущих сообщений.

При дисковом шифровании синхропосылка строится по номеру того сектора, который
зашифровывается. Всякий раз при шифровании сектора используется одна и та же
синхропосылка. Синхропосылки различных секторов должны различаться.

\section{Имитовставка}\label{COMMON.MAC}

В алгоритме выработки имитовставки и в алгоритмах аутентифицированного шифрования
данных вычисляется либо проверяется имитовставка~$T\in\{0,1\}^{64}$.

Если требуются не все, а~$n<64$ символов имитовставки, 
то должны использоваться первые~$n$ символов.
%
При выборе~$n$ следует учитывать, что при навязывании ложного сообщения 
вероятность угадать с одной попытки его имитовставку, не зная ключ,
равняется~$2^{-n}$.

\section{Хэш-значение}

В алгоритме хэширования вычисляется хэш-значение~$Y\in\{0,1\}^{256}$.

Если требуются не все, а~$n<256$ символов хэш-значения, 
то должны использоваться первые~$n$ символов.
%
При выборе~$n$ следует учитывать, 
что для определения сообщения с заданным хэш-значением
требуется выполнить порядка~$2^n$ операций,
а для определения двух различных сообщений
с одинаковыми хэш-значениями требуется выполнить
порядка~$2^{n/2}$ операций.

\section{Интерфейсы}\label{COMMON.IFace}

Определение группы алгоритмов начинается с назначения алгоритмам коротких 
имен и описания соглашений о входных и выходных данных алгоритмов.
В совокупности такая вводная информация называется интерфейсом.
%
Например, алгоритму шифрования блока, определенному в~\ref{BLOCK},
назначается имя~$\algname{belt-block}$ и объявляется, что входными 
данными являются блок~$X\in\{0,1\}^{128}$ и ключ~$K\in\{0,1\}^{256}$,
а выходными~--- блок~$Y\in\{0,1\}^{128}$.

Как правило, интерфейс каждой группы описывает два алгоритма: зашифрования 
или установки защиты и расшифрования или снятия защиты. Например, 
алгоритм зашифрования~$\algname{belt-block}$ сопровождается 
алгоритмом расшифрования~$\algname{belt-block}^{-1}$.

С помощью интерфейсов можно лаконично и однозначно 
описывать вызов одних алгоритмов в других.
%        	
Например, вызов~$\algname{belt-block}$ 
записывается как~$Y\leftarrow\algname{belt-block}(X,K)$.

Алгоритм может вызываться в других алгоритмах настоящего стандарта или 
в алгоритмах других стандартов. И наоборот алгоритм может вызывать другие 
алгоритмы. В последнем случае интерфейс содержит перечень задействованных 
алгоритмов.

Интерфейсы описывают алгоритмы, в которых используются $256$-битовые 
ключи. Для указания на использование ключей других длин к короткому 
имени алгоритма следует добавить длину ключа:
$\algname{belt-block128}$, $\algname{belt-block192}^{-1}$ и т.д.
%
Имена с суффиксом \algname{256} (например, $\algname{belt-block256}$) 
являются синонимами первоначальных имен и могут быть использованы вместо них.

\section{Переменные}\label{COMMON.Vars}

\addendum{
В настоящем стандарте переменные алгоритма, которые явно объявляются перед 
определением его шагов, могут содержать критические данные, например, фрагмент 
ключа или промежуточный результат вычислений, который упрощает определение 
этого фрагмента.
}
%
Речь идет, в том числе, о переменных алгоритма хэширования, 
который может использоваться для обработки критических данных.

При реализации алгоритм\addendum{а} объявленные переменные должны очищаться после 
использования. 

Реализации могут не буквально следовать описанию алгоритма.
Например, переменная алгоритма может быть представлена несколькими 
переменными реализации. При организации очистки необходимо учитывать 
особенности реализации.

Очистка переменных алгоритма может не выполняться, если алгоритм все-таки 
не обрабатывает и не возвращает критические данные.
%
Переменные могут также не очищаться, если алгоритм выполняется в защищенной 
среде, и доступ к переменным блокируется аппаратными или другими способами.

\if 0
Алгоритмы должны быть реализованы так, чтобы время их выполнения не 
менялось в зависимости от входных данных, но возможно зависело от 
размерностей данных. Особенно это касается алгоритмов шифрования с 
сохранением формата. В этих алгоритмах используются арифметика больших 
чисел.
\fi
